// ===============================
// 약관 텍스트 (변수로 관리)
// ===============================

const TERMS_SERVICE = `
[CareBridge 이용약관]

제1조 (목적)
본 약관은 CareBridge(이하 “회사”)가 제공하는 웹/모바일 기반 서비스(이하 “서비스”)의 이용과 관련하여 회사와 이용자 간의 권리, 의무 및 책임사항, 기타 필요한 사항을 규정함을 목적으로 합니다.

제2조 (용어의 정의)
① “이용자”란 본 약관에 따라 회사가 제공하는 서비스를 이용하는 회원 및 비회원을 말합니다.
② “회원”이란 서비스에 회원가입을 하고 회사가 제공하는 서비스를 지속적으로 이용할 수 있는 자를 말합니다.
③ “계정”이란 회원의 식별 및 서비스 이용을 위하여 회원이 설정한 아이디(ID) 및 비밀번호 등 인증 수단을 말합니다.
④ “콘텐츠”란 회사가 서비스에서 제공하거나 이용자가 서비스에 게시한 문자, 이미지, 동영상, 정보, 데이터, 링크 등 일체의 자료를 말합니다.

제3조 (약관의 효력 및 변경)
① 본 약관은 회원이 약관에 동의하고 회원가입을 완료한 시점부터 효력이 발생합니다.
② 회사는 관련 법령을 위배하지 않는 범위 내에서 약관을 변경할 수 있으며, 약관을 변경하는 경우 적용일자 및 변경사유를 명시하여 서비스 내 공지 또는 개별 통지합니다.
③ 회원이 변경된 약관에 동의하지 않는 경우 회원 탈퇴(이용계약 해지)를 요청할 수 있으며, 회사가 고지한 기간 내에 거부 의사를 표시하지 않으면 변경 약관에 동의한 것으로 봅니다.

제4조 (회원가입 및 정보의 제공)
① 회원가입은 이용자가 약관에 동의하고 회사가 정한 가입 절차에 따라 가입 신청을 하면 회사가 이를 승낙함으로써 체결됩니다.
② 이용자는 가입 신청 시 사실에 기반한 정확한 정보를 제공해야 하며, 허위 또는 타인의 정보를 사용한 경우 서비스 이용이 제한될 수 있습니다.
③ 회원은 회원정보 변경(연락처, 이메일 등)이 발생한 경우 지체 없이 수정해야 하며, 미수정으로 인한 불이익은 회원에게 있습니다.

제5조 (계정 및 비밀번호 관리)
① 계정 및 비밀번호 등 인증정보의 관리 책임은 회원에게 있으며, 제3자에게 양도·대여·공유할 수 없습니다.
② 회원의 관리 소홀, 부정 사용으로 발생한 손해에 대하여 회사는 회사의 귀책사유가 없는 한 책임을 부담하지 않습니다.
③ 회원은 계정 도용 또는 비정상 사용을 인지한 경우 즉시 회사에 통지해야 합니다.

제6조 (서비스의 제공 및 변경)
① 회사는 회원에게 다음과 같은 서비스를 제공합니다.
  1. 의료기관 정보 조회 및 검색 기능
  2. 예약, 상담, 안내 등 서비스 제공(서비스 제공 범위는 회사 정책에 따라 변동 가능)
  3. 서비스 이용 관련 알림(공지, 안내, 상태 변경 등)
  4. 기타 회사가 정하는 부가 서비스
② 회사는 운영상·기술상 필요한 경우 서비스의 전부 또는 일부를 변경하거나 중단할 수 있습니다.
③ 회사가 서비스를 변경하거나 중단하는 경우, 가능한 경우 사전 공지하되 불가피한 경우 사후 공지할 수 있습니다.

제7조 (서비스 이용 시간 및 중단)
① 회사는 특별한 사유가 없는 한 연중무휴 24시간 서비스를 제공함을 원칙으로 합니다.
② 다음 사유가 발생한 경우 서비스 제공이 일시 중단될 수 있습니다.
  1. 시스템 점검, 증설, 교체 등 유지보수
  2. 장애 발생, 통신망 장애, 외부 서비스 연동 문제
  3. 천재지변, 국가비상사태, 정전 등 불가항력
③ 회사는 서비스 중단에 대해 회사의 고의 또는 중대한 과실이 없는 한 책임을 지지 않습니다.

제8조 (이용자의 의무)
이용자는 서비스를 이용함에 있어 다음 행위를 하여서는 안 됩니다.
① 타인의 개인정보, 계정 도용 또는 부정 사용
② 서비스 운영 방해(해킹, 악성코드 유포, 과도한 트래픽 유발 등)
③ 허위 정보 등록, 타인 비방, 명예훼손, 불법 홍보
④ 저작권 등 지식재산권 침해
⑤ 관계 법령 및 공서양속에 반하는 행위

제9조 (게시물 및 콘텐츠의 관리)
① 이용자가 서비스에 게시한 게시물의 책임은 이용자에게 있습니다.
② 회사는 다음에 해당하는 게시물에 대해 사전 통지 없이 삭제 또는 접근 제한을 할 수 있습니다.
  1. 법령 위반 또는 타인의 권리 침해가 명백한 경우
  2. 음란·폭력·혐오 등 부적절한 내용
  3. 허위 정보 또는 오해를 유발할 수 있는 내용
  4. 광고, 스팸, 반복 게시 등 서비스 운영에 지장을 주는 경우
③ 회사는 게시물의 삭제로 발생한 손해에 대해 회사의 귀책사유가 없는 한 책임을 부담하지 않습니다.

제10조 (이용 제한 및 해지)
① 회사는 이용자가 본 약관 또는 관련 법령을 위반한 경우 사전 통지 없이 서비스 이용을 제한할 수 있습니다.
② 회원은 언제든지 서비스 내 절차 또는 고객센터를 통해 이용계약 해지를 요청할 수 있습니다.
③ 회사는 부정 이용 방지 및 법령 준수를 위해 필요한 경우, 추가 인증 또는 서류 제출을 요청할 수 있습니다.

제11조 (면책 및 책임 제한)
① 회사는 의료기관, 의료행위 자체의 품질, 진단·처방 등 의료행위에 직접 관여하지 않으며 이에 대한 책임을 부담하지 않습니다.
② 회사는 이용자 간 또는 이용자와 제3자 간 분쟁에 개입하지 않으며, 회사의 귀책사유가 없는 한 책임을 부담하지 않습니다.
③ 회사는 무료로 제공되는 서비스에 대해 법령상 허용되는 범위 내에서 책임을 제한할 수 있습니다.

제12조 (준거법 및 관할)
① 본 약관은 대한민국 법령을 준거법으로 합니다.
② 서비스 이용과 관련하여 회사와 이용자 간 발생한 분쟁에 관한 소송은 민사소송법상 관할 법원에 제기합니다.

부칙
본 약관은 공지한 날로부터 시행합니다.
`.trim();


const TERMS_PRIVACY = `
[개인정보 수집·이용 동의]

회사는 「개인정보 보호법」 등 관련 법령에 따라 이용자의 개인정보를 안전하게 처리하며, 아래와 같이 개인정보를 수집·이용합니다.

1. 수집하는 개인정보 항목
① 회원가입 및 서비스 이용 과정에서 수집
- 필수: 이름, 아이디(ID), 비밀번호, 연락처(휴대전화), 이메일, 성별
- 선택: 주소, 프로필 이미지, 소속/선택 병원 정보(의료진 또는 병원 관련 기능 이용 시)
② 서비스 이용 과정에서 자동 생성·수집될 수 있는 정보
- 접속 로그, IP 정보, 쿠키, 이용 기록, 기기 정보(브라우저/OS 등), 오류 기록

2. 개인정보 수집·이용 목적
회사는 다음 목적을 위해 개인정보를 수집·이용합니다.
① 회원 식별 및 본인 확인, 회원 관리(가입/탈퇴, 부정 이용 방지)
② 서비스 제공 및 운영(예약/상담/알림 제공, 사용자 요청 처리)
③ 고객 문의 및 민원 처리(분쟁 해결, 공지 전달)
④ 서비스 품질 개선 및 신규 기능 개발(통계/분석은 가능한 범위에서 비식별화 또는 최소화하여 처리)

3. 개인정보 보유 및 이용 기간
① 원칙적으로 회원 탈퇴 시까지 보유 및 이용합니다.
② 다만, 관련 법령에 따라 보관이 필요한 경우 해당 기간 동안 보관합니다.
- 계약 또는 청약철회 등에 관한 기록: 법령에 따른 기간
- 소비자의 불만 또는 분쟁처리에 관한 기록: 법령에 따른 기간
- 접속 기록 등 서비스 이용 기록: 법령에 따른 기간 또는 내부 정책에 따른 기간

4. 개인정보 제공 및 위탁
① 회사는 원칙적으로 이용자의 개인정보를 제3자에게 제공하지 않습니다.
② 다만 다음의 경우에는 예외로 합니다.
- 이용자가 사전에 동의한 경우
- 법령에 따라 제공이 요구되는 경우(수사기관 요청 등)
③ 회사는 서비스 제공을 위해 개인정보 처리업무를 외부에 위탁할 수 있으며,
위탁 시 관련 법령에 따라 안전하게 관리·감독합니다.
(위탁이 발생하는 경우 서비스 내 별도 고지 또는 개인정보처리방침을 통해 공개)

5. 이용자의 권리 및 행사 방법
① 이용자는 자신의 개인정보에 대해 열람, 정정, 삭제, 처리정지 등을 요구할 수 있습니다.
② 이용자는 동의 철회(회원 탈퇴)를 통해 개인정보 수집·이용에 대한 동의를 철회할 수 있습니다.
③ 권리 행사는 서비스 내 기능 또는 고객센터를 통해 요청할 수 있으며, 회사는 지체 없이 조치합니다.

6. 개인정보 보호를 위한 조치
회사는 개인정보 보호를 위해 다음과 같은 조치를 시행합니다.
① 관리적 조치: 내부 관리계획 수립, 접근 권한 최소화, 교육 실시
② 기술적 조치: 비밀번호 암호화(해시), 접근통제, 로그 관리, 보안 업데이트
③ 물리적 조치: 서버 및 인프라 접근 통제

7. 동의 거부 권리 및 불이익
이용자는 개인정보 수집·이용에 대한 동의를 거부할 권리가 있습니다.
다만, 필수 항목에 대한 동의를 거부할 경우 회원가입 및 서비스 제공이 제한될 수 있습니다.

부칙
본 동의 내용은 관련 법령 또는 회사 정책에 따라 변경될 수 있으며,
변경 시 서비스 내 공지 또는 별도 안내를 통해 알려드립니다.
`.trim();


document.addEventListener("DOMContentLoaded", () => {
  const modal = document.getElementById("termsModal");
  const modalTitle = document.getElementById("modalTitle");
  const modalBody = document.getElementById("modalBody");

  const linkA = document.getElementById("terms_link_a");
  const linkB = document.getElementById("terms_link_b");

  if (!modal || !modalTitle || !modalBody) return;

  const closeBtn = modal.querySelector(".modal-close");
  const overlay = modal.querySelector(".modal-overlay");

  const termsData = {
    service: {
      title: "이용약관",
      body: TERMS_SERVICE
    },
    privacy: {
      title: "개인정보 수집·이용 동의",
      body: TERMS_PRIVACY
    }
  };

  function openModal(type) {
    modalTitle.textContent = termsData[type].title;
    modalBody.textContent = termsData[type].body;
    modal.classList.remove("hidden");

    // ✅ 스크롤 초기화(중요)
    modalBody.scrollTop = 0;
    modalBody.scrollTo({ top: 0, left: 0, behavior: "auto" });
  }

  function closeModal() {
    modal.classList.add("hidden");
  }

  if (linkA) {
    linkA.addEventListener("click", (e) => {
      e.preventDefault();
      openModal("service");
    });
  }

  if (linkB) {
    linkB.addEventListener("click", (e) => {
      e.preventDefault();
      openModal("privacy");
    });
  }

  if (closeBtn) closeBtn.addEventListener("click", closeModal);
  if (overlay) overlay.addEventListener("click", closeModal);

  // ESC로 닫기(선택)
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closeModal();
  });
});


const checkUsernameBtn = document.getElementById("check-username-btn");

if (checkUsernameBtn) {
  checkUsernameBtn.addEventListener("click", function () {
      const usernameInput = document.getElementById("id_username");
      const username = usernameInput.value.trim();
      const msgEl = document.getElementById("username-msg");

      if (username.length === 0) {
          msgEl.textContent = "아이디를 입력해주세요.";
          msgEl.style.color = "red";
          return;
      }

      fetch(`/accounts/check-username/?username=${encodeURIComponent(username)}`)
          .then(res => res.json())
          .then(data => {
              if (data.exists) {
                  msgEl.textContent = "이미 사용 중인 아이디입니다.";
                  msgEl.style.color = "red";
              } else {
                  msgEl.textContent = "사용 가능한 아이디입니다.";
                  msgEl.style.color = "green";
              }
          })
          .catch(() => {
              msgEl.textContent = "중복 확인 중 오류가 발생했습니다.";
              msgEl.style.color = "red";
          });
  });
}

// 전화번호 자동 하이픈
const phoneInput = document.getElementById('id_phone');

if (phoneInput) {
  phoneInput.addEventListener('input', function (e) {
    let value = e.target.value.replace(/[^0-9]/g, '');
    if (value.length > 3 && value.length <= 7) {
      value = value.replace(/(\d{3})(\d+)/, '$1-$2');
    } else if (value.length > 7) {
      value = value.replace(/(\d{3})(\d{4})(\d+)/, '$1-$2-$3');
    }
    e.target.value = value;
  });
}

// 주민등록번호 앞/뒤
const rrnFrontInput = document.getElementById('rrn_front');
const rrnBackInput  = document.getElementById('rrn_back');
const residentRegHidden = document.getElementById('resident_reg_no');

let rrnBackReal = '';

// 주민등록번호 뒷자리 * 마스킹
if (rrnBackInput) {
  rrnBackInput.addEventListener('keydown', function (e) {
    const ctrlKeys = ['Tab', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];

    if (ctrlKeys.includes(e.key)) {
      return;
    }

    // 백스페이스
    if (e.key === 'Backspace') {
      rrnBackReal = rrnBackReal.slice(0, -1);
      setTimeout(() => {
        rrnBackInput.value = '*'.repeat(rrnBackReal.length);
      }, 0);
      e.preventDefault();
      return;
    }

    // 숫자 아닌 것, 길이 7 초과 막기
    if (!/^[0-9]$/.test(e.key) || rrnBackReal.length >= 7) {
      if (e.key.length === 1) {
        e.preventDefault();
      }
      return;
    }

    // 정상 숫자 입력
    rrnBackReal += e.key;
    setTimeout(() => {
      rrnBackInput.value = '*'.repeat(rrnBackReal.length);
    }, 0);
    e.preventDefault();
  });

  rrnBackInput.addEventListener('paste', function (e) {
    e.preventDefault();
  });
}
// ===== 이메일 도메인 텍스트박스 제어 =====
const domainSelect = document.getElementById("email_domain_select");
const domainText   = document.getElementById("email_domain_text");

domainSelect.addEventListener("change", function () {
    const value = this.value;

    if (value === "") {
        domainText.value = "";
        domainText.readOnly = false;
        domainText.placeholder = "도메인 입력";
    }
    else if (value === "custom") {
        domainText.value = "";
        domainText.readOnly = false;
        domainText.placeholder = "도메인 직접 입력";
        domainText.focus();
    }
    else {
        domainText.value = value;
        domainText.readOnly = true;
    }
});

document.getElementById("registerForm").addEventListener("submit", function (e) {
    const local = document.getElementById("email_local").value.trim();
    const domain = domainText.value.trim();
    const finalEmailInput = document.getElementById("email");

    if (!local || !domain) {
        alert("올바른 이메일을 입력해주세요.");
        e.preventDefault();
        return;
    }
    finalEmailInput.value = `${local}@${domain}`;
});

const pwRegex = /^(?=.*[A-Za-z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]).{8,16}$/;

const form = document.getElementById('registerForm');
const pw1  = document.getElementById('id_password1');
const pw2  = document.getElementById('id_password2');

const pwRuleMsg     = document.getElementById('pw-rule-msg');
const pwDefaultMsg     = document.getElementById('pw-help-msg');
const pwMismatchMsg = document.getElementById('pw-mismatch-msg');

// ① 비밀번호 규격 체크
function checkPwRule() {
  if (!pw1 || !pwRuleMsg) return true;

  if (!pw1.value) {
    pwRuleMsg.style.display = 'none';
    pwDefaultMsg.style.display = 'block';
    pw1.classList.remove('input-error');
    return true;
  }

  if (!pwRegex.test(pw1.value)) {
    pwRuleMsg.style.display = 'block';
    pwDefaultMsg.style.display = 'none';
    pw1.classList.add('input-error');
    pw1.classList.add('input-error');
    return false;
  } else {
    pwRuleMsg.style.display = 'none';
    pwDefaultMsg.style.display = 'none';
    pw1.classList.remove('input-error');
    return true;
  }
}

// ② 비밀번호 일치 체크
function checkPwMatch() {
  if (!pw1 || !pw2 || !pwMismatchMsg) return true;

  // 규격이 안 맞으면 일치 체크는 하지 않음
  if (!checkPwRule()) {
    pwMismatchMsg.style.display = 'none';
    pw2.classList.remove('input-error');
    return false;
  }

  if (pw1.value && pw2.value && pw1.value !== pw2.value) {
    pwMismatchMsg.style.display = 'block';
    pw2.classList.add('input-error');
    return false;
  } else {
    pwMismatchMsg.style.display = 'none';
    pw2.classList.remove('input-error');
    return true;
  }
}

// 실시간/포커스 아웃 이벤트
if (pw1 && pw2) {
  pw1.addEventListener('input', checkPwRule);
  pw1.addEventListener('blur', checkPwRule);

  pw2.addEventListener('input', checkPwMatch);
  pw2.addEventListener('blur', checkPwMatch);
}
const termsAll  = document.getElementById("terms_all");
const termItems = document.querySelectorAll(".terms-list input[type='checkbox']");

if (termsAll && termItems.length > 0) {
  // 전체 동의 클릭 시 → 모든 체크박스 변경
  termsAll.addEventListener("change", function () {
      termItems.forEach(chk => {
          chk.checked = termsAll.checked;
      });
  });

  // 개별 체크박스 변경 시 → 전체 동의 상태 업데이트
  termItems.forEach(chk => {
      chk.addEventListener("change", function () {
          const allChecked = Array.from(termItems).every(item => item.checked);
          termsAll.checked = allChecked;
      });
  });
}
if (form) {
  form.addEventListener('submit', function (e) {

    // provider는 URL 말고 hidden input 값을 신뢰하는 게 안전함
    const providerInput = document.querySelector('input[name="provider"]');
    const provider = providerInput ? providerInput.value : "local";
    const isKakao = (provider === "kakao");

    // 1) 비밀번호 검사는 local만
    if (!isKakao) {
      const validRule  = checkPwRule();
      const validMatch = checkPwMatch();

      if (!validRule) {
        alert('비밀번호 규격이 올바르지 않습니다.');
        pw1 && pw1.focus();
        e.preventDefault();
        return;
      }

      if (!validMatch) {
        alert('비밀번호가 서로 일치하지 않습니다.');
        pw2 && pw2.focus();
        e.preventDefault();
        return;
      }
    }

    // 2) ✅ 주민등록번호는 kakao/local 모두 hidden에 반드시 합쳐서 넣기
    const front = rrnFrontInput ? rrnFrontInput.value.replace(/[^0-9]/g, '') : '';

    if (!front || front.length !== 6 || rrnBackReal.length !== 7) {
      alert('주민등록번호를 정확히 입력해주세요.');
      e.preventDefault();
      return;
    }

    if (residentRegHidden) {
      residentRegHidden.value = front + '-' + rrnBackReal;
    }
  });
}
const licenseInput = document.getElementById("id_license_number");
const licenseRegex = /^[A-Za-z]{2}\$[0-9]{7}$/;

licenseInput.addEventListener("input", function () {
    const value = licenseInput.value.trim();

    if (!licenseRegex.test(value)) {
        licenseInput.classList.add('input-error');
        document.getElementById("license_help").style.display = 'block';
    } else {
        licenseInput.classList.remove('input-error');
        document.getElementById("license_help").style.display = 'none';
    }
});

const fileInput   = document.getElementById('id_profile_image');
const previewImg  = document.getElementById('profilePreview');
const resetButton = document.getElementById('resetProfileImage');
const terms_link_a = document.getElementById('terms_link_a');
const terms_link_b = document.getElementById('terms_link_b');
if (fileInput && previewImg) {
  // 1) 파일 선택 시 미리보기
  fileInput.addEventListener('change', function () {
    const file = fileInput.files[0];
    if (!file) return;

    const url = URL.createObjectURL(file);
    previewImg.src = url;
  });
}

if (resetButton && fileInput && previewImg) {
  // 2) 기본 이미지로 되돌리기
  resetButton.addEventListener('click', function () {
    const defaultSrc = previewImg.dataset.defaultSrc || previewImg.getAttribute('data-default-src');

    // 미리보기 이미지 원상복구
    if (defaultSrc) {
      previewImg.src = defaultSrc;
    }

    // 파일 인풋 비우기 (업로드 취소)
    fileInput.value = '';
  });
}
// ===== 병원 검색 모달 =====
const hospitalAddrInput   = document.getElementById("id_hospital_addr");
const hospitalSearchBtn   = document.getElementById("hospital-search-btn");
const hospitalModal       = document.getElementById("hospital-modal");
const hospitalModalClose  = document.getElementById("hospital-modal-close");
const hospitalSearchInput = document.getElementById("hospital-search-input");
const hospitalResultsBody = document.getElementById("hospital-results-body");
const hospitalIdHidden    = document.getElementById("hospital_id");

function openHospitalModal() {
  if (!hospitalModal) return;
  hospitalModal.classList.remove("hidden");
  if (hospitalSearchInput) {
    hospitalSearchInput.value = "";
    hospitalResultsBody.innerHTML = "";
    hospitalSearchInput.focus();
  }
}

function closeHospitalModal() {
  if (!hospitalModal) return;
  hospitalModal.classList.add("hidden");
}

// 인풋 클릭하거나 버튼 클릭 시 모달 열기
if (hospitalAddrInput) {
  hospitalAddrInput.addEventListener("click", openHospitalModal);
}
if (hospitalSearchBtn) {
  hospitalSearchBtn.addEventListener("click", openHospitalModal);
}

// 닫기 버튼
if (hospitalModalClose) {
  hospitalModalClose.addEventListener("click", closeHospitalModal);
}
// 배경 클릭 시 닫기
if (hospitalModal) {
  hospitalModal.addEventListener("click", function (e) {
    if (e.target === hospitalModal) {
      closeHospitalModal();
    }
  });
}

// 디바운스 유틸
function debounce(fn, delay) {
  let timer = null;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// 검색 요청
async function fetchHospitals(q) {
  if (!q || q.trim().length === 0) {
    hospitalResultsBody.innerHTML = "";
    return;
  }

  try {
    const resp = await fetch(`${HOSPITAL_SEARCH_URL}?q=${encodeURIComponent(q)}`, {
      headers: { "X-Requested-With": "XMLHttpRequest" },
    });
    if (!resp.ok) return;
    const data = await resp.json();

    hospitalResultsBody.innerHTML = "";

    if (!data.results || data.results.length === 0) {
      hospitalResultsBody.innerHTML =
        `<tr><td colspan="2" style="text-align:center;">검색 결과가 없습니다.</td></tr>`;
      return;
    }

    data.results.forEach((h) => {
      const tr = document.createElement("tr");
      tr.classList.add("hospital-row");
      tr.dataset.id = h.id;
      tr.dataset.name = h.name;
      tr.dataset.address = h.address;

      tr.innerHTML = `
        <td>${h.name}</td>
        <td>${h.address}</td>
      `;
      hospitalResultsBody.appendChild(tr);
    });
  } catch (err) {
    console.error(err);
  }
}

const debouncedFetchHospitals = debounce(function () {
  fetchHospitals(hospitalSearchInput.value);
}, 300);

// 입력 시 실시간 검색
if (hospitalSearchInput) {
  hospitalSearchInput.addEventListener("input", debouncedFetchHospitals);
}

// 결과 클릭 시 선택
if (hospitalResultsBody) {
  hospitalResultsBody.addEventListener("click", function (e) {
    const tr = e.target.closest("tr.hospital-row");
    if (!tr) return;

    const id      = tr.dataset.id;
    const name    = tr.dataset.name;
    const address = tr.dataset.address;

    // 화면에는 병원명 + 주소나, 원하는 포맷으로 표기
    if (hospitalAddrInput) {
      hospitalAddrInput.value = `${name}`;
    }
    if (hospitalIdHidden) {
      hospitalIdHidden.value = id;
    }
    closeHospitalModal();
  });
}
terms_link_a.addEventListener("click", function(e){
  alert('a');
});
terms_link_b.addEventListener("click", function(e){
  alert('b');
});
function openPostcodeSearch() {
    new daum.Postcode({
        oncomplete: function(data) {
            var addr = '';
            var extraAddr = '';

            if (data.userSelectedType === 'R') {
                addr = data.roadAddress;
            } else {
                addr = data.jibunAddress;
            }
            if (data.userSelectedType === 'R') {
                if (data.bname !== '' && /[동|로|가]$/g.test(data.bname)) {
                    extraAddr += data.bname;
                }
                if (data.buildingName !== '' && data.apartment === 'Y') {
                    extraAddr += (extraAddr !== '' ? ', ' + data.buildingName : data.buildingName);
                }
            }
            document.getElementById('addr_num').value = data.zonecode;
            document.getElementById('addr').value = addr;
            document.getElementById('addr_detail').focus();
            updateFullAddress();
        }
    }).open();
}

function updateFullAddress() {
    const zip = document.getElementById('addr_num').value;
    const address = document.getElementById('addr').value;
    const detail = document.getElementById('addr_detail').value;

    document.getElementById('address_full').value =
        `[${zip}] ${address} ${detail}`.trim();
}

// 상세주소 입력 시 hidden 값 업데이트
document.addEventListener("input", function(e) {
    if (e.target.id === "addr_detail") {
        updateFullAddress();
    }
});